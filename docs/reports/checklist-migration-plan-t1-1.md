# План миграции чек-листа к плоской модели (T1.1)

_Дата подготовки: 25.09.2025 (assistant)_

## 1. Цель и границы задачи

Этап T1.1 отвечает за преобразование текущей иерархии чек-листа «категория → секция → вопрос → варианты баллов» в плоскую структуру `ChecklistItem`, предусмотренную архитектурой 3.0. Цель — подготовить набор миграций, которые создадут новые сущности (`ChecklistTemplate`, `ChecklistItem`) и перенесут данные, сохранив порядок вопросов, правила расчёта баллов и требования к комментариям.【F:docs/architecture/v3.md†L11-L58】【F:docs/reports/data-inventory-2025-09-24.md†L11-L29】 В рамках T1.1 мы проектируем схему и сценарии миграции; фактическое применение изменений в коде и удаление старых моделей перейдёт в этап T2.1.

## 2. Исходное состояние

Текущая модель включает четыре связанные таблицы: `ChecklistCategory`, `ChecklistSection`, `ChecklistQuestion`, `ScoreOption`. Категории управляются по `code` и `order`, секции группируют вопросы внутри категории, каждый вопрос хранит тип (`score/boolean/text`), максимальный балл, подсказку и флаг обязательного комментария, а варианты баллов задаются отдельной сущностью с уникальностью по порядку и значению.【F:backend/catalog/models.py†L272-L520】 Дополнительные бизнес-правила реализованы в `validate_answer()` и сериализации вопроса: комментарий может требоваться только при снижении оценки ниже максимальной, что вычисляется на основе `ScoreOption` и `max_score`.【F:backend/catalog/models.py†L420-L469】【F:backend/audits/services.py†L105-L184】

## 3. Целевая схема данных

### 3.1. ChecklistTemplate

| Поле | Тип | Назначение |
| --- | --- | --- |
| `id` | PK | Уникальный идентификатор версии чек-листа. |
| `title` | `CharField(255)` | Отображаемое название версии; используется в UI и при экспортах. |
| `description` | `TextField(blank=True)` | Краткие примечания о содержании чек-листа. |
| `is_active` | `BooleanField` | Флаг текущей публикуемой версии (одна активная запись). |
| `published_at` | `DateTimeField(null=True)` | Время публикации версии, нужно для аудита изменений. |
| `created_at` / `updated_at` | `DateTimeField` | Автоматические метки для исторического анализа. |

Модель реализует версионирование, описанное в целевой архитектуре: новые версии чек-листа копируют структуру предыдущей без сложной ветвистости.【F:docs/architecture/v3.md†L45-L57】

### 3.2. ChecklistItem

| Поле | Тип | Назначение |
| --- | --- | --- |
| `id` | PK | Уникальный идентификатор пункта. |
| `template` | FK → `ChecklistTemplate` | Привязка к версии чек-листа. |
| `order` | `PositiveIntegerField` | Глобальный порядок вывода в интерфейсе. |
| `area` | `CharField(120)` | Название зоны/локации (например, «Холл», «Машинное помещение»). |
| `category` | `CharField(120)` | Тематическая категория («Комфорт», «Безопасность»). |
| `code` | `CharField(50, blank=True)` | Необязательный короткий идентификатор для импорта/экспорта. |
| `text` | `TextField` | Формулировка вопроса. |
| `guideline` | `TextField(blank=True)` | Инструкции и критерии оценки. |
| `answer_type` | `CharField(20)` | `number` / `boolean` / `text`; упрощённая замена текущего `type`. |
| `min_score` / `max_score` / `step` | `IntegerField` | Числовые пределы шкалы для `number`-вопросов (при отсутствии явных опций). |
| `options` | `JSONField(null=True)` | Список словарей `{ "value": <str|int|bool>, "score": <int>, "label": <str>, "requires_comment": <bool> }` для явных градаций. |
| `weight` | `DecimalField(default=1)` | Вес пункта в агрегированном балле (по умолчанию равен `max_score`). |
| `requires_comment_always` | `BooleanField(default=False)` | Флаг обязательного комментария независимо от оценки. |
| `requires_comment_below_max` | `BooleanField(default=False)` | Флаг обязательного комментария, если балл меньше максимального (замена текущей логики). |
| `is_active` | `BooleanField(default=True)` | Позволяет временно исключить пункт без удаления. |

Такая структура покрывает требования архитектуры по зонам, категориям и шкалам и повторяет бизнес-правила комментариев, реализованные сейчас через методы модели и сериализацию.【F:docs/architecture/v3.md†L11-L58】【F:backend/catalog/models.py†L420-L469】【F:backend/audits/services.py†L105-L133】 Использование `JSONField` для `options` устраняет необходимость отдельной таблицы и упрощает импорт/экспорт CSV, сохраняя возможность хранить текст описания и признак обязательного комментария для каждой градации.

### 3.3. Служебная таблица соответствия

Для поддержки миграций T2.1/T5.2 требуется таблица `ChecklistLegacyMapping` с полями `old_question_id`, `new_item_id`, `template_id`, `category_id`, `section_id`. Она позволит перенести `AuditResponse` и журналы, а также отладить отчёты при сравнении результатов до и после миграции.

## 4. Стратегия миграции

### 4.1. Шаг 1 — подготовка схемы

1. Создать модели `ChecklistTemplate`, `ChecklistItem`, `ChecklistLegacyMapping` в приложении `catalog`.
2. Добавить миграцию, которая создаёт уникальный индекс на `(template, order)` и частичный индекс на `(template, code)` (для ускорения импорта/поиска).
3. Зарезервировать перечисление `ChecklistItem.AnswerType` (`number`, `boolean`, `text`) и валидаторы для `options` (проверка уникальности `value`, соответствия `score` диапазону `min/max`).

### 4.2. Шаг 2 — заполнение шаблонов

1. В постмиграционном скрипте создать запись `ChecklistTemplate` «Чек-лист 2025» (название уточняется с методологами) и пометить её активной.
2. Зафиксировать `published_at` датой запуска миграции; `created_at`/`updated_at` выставятся автоматически.
3. При наличии нескольких независимых наборов вопросов (например, специализированные анкеты) — создавать отдельные шаблоны по данным инвентаризации.

### 4.3. Шаг 3 — перенос пунктов

1. Получить категории и секции с предзагруженными вопросами и вариантами баллов. Порядок нового пункта рассчитывается как `(category.order * 10_000) + (section.order * 100) + question.order` для сохранения относительного упорядочивания без промежуточных сдвигов.
2. Определить `area` и `category`:
   - `area` ← `ChecklistSection.title` (в инвентаризации отмечено соответствие зонам/локациям по данным `data.csv`).【F:docs/reports/data-inventory-2025-09-24.md†L26-L29】
   - `category` ← `ChecklistCategory.name`.
   - `code` ← `ChecklistCategory.code` + `section.order` + `question.order` (например, `safety-01-05`), чтобы сохранить стабильные идентификаторы при импорте.
3. Для вопросов типа `score`:
   - Если варианты баллов заданы (`ScoreOption`), преобразовать их в JSON-структуру `options`, сохранив порядок и описания.【F:backend/catalog/models.py†L472-L509】
   - `min_score` ← минимальное значение `ScoreOption.score`, `max_score` ← максимальное, `step` ← НОД соседних разниц (если `options` непрерывны); иначе `step = 0` для произвольных шкал.
   - `requires_comment_below_max` устанавливается, если в текущей логике `requires_comment_for_score()` возвращает `True` для хотя бы одного варианта с баллом ниже максимума.【F:backend/catalog/models.py†L420-L469】【F:backend/audits/services.py†L113-L133】
   - `requires_comment_always` копирует `ChecklistQuestion.requires_comment`.
4. Для `boolean` вопросов задать `answer_type = boolean`, `options = [{"value": true, "score": question.max_score, ...}, {"value": false, "score": 0, ...}]`, сохранить подписи «Да»/«Нет» из локализаций форм. При необходимости `max_score` берётся из `question.max_score`, `min_score`=0, `step`=question.max_score.
5. Для `text` вопросов `answer_type = text`, числовые поля обнуляются, `options = null`, `requires_comment_always` наследуется из вопроса.
6. `weight` по умолчанию равен `max_score` (для сохранения суммарных значений `total_score` до уточнения методологии). Дополнительно фиксируется TODO на пересмотр формулы в рамках T2.2.
7. Для каждого созданного `ChecklistItem` записывать соответствие в `ChecklistLegacyMapping`.

### 4.4. Шаг 4 — валидация данных

1. Проверить, что количество созданных пунктов совпадает с количеством исходных вопросов (`ChecklistQuestion.objects.count()`), а количество опций по каждому вопросу совпадает с числом записей в `ScoreOption`.
2. Сгенерировать контрольный отчёт (CSV) с полями `old_question_id`, `new_item_id`, `area`, `category`, `text`, `max_score`, `options_count` и сохранить в `deploy/artifacts/` для ревью методологов.
3. Пересчитать суммарный балл для одного тестового аудита на копии базы, сравнив результаты до и после миграции (используя JSON-дампы ответов).

### 4.5. Шаг 5 — поэтапное выключение старых сущностей

1. После обновления сервисов, использующих `ChecklistQuestion`, `ChecklistSection`, `ChecklistCategory`, добавить новые FK/ссылки на `ChecklistItem`.
2. На время перехода держать обе модели доступными в режиме чтения, используя представления Django для обратной совместимости (например, сериализатор, который отдаёт структуру и в старом, и в новом формате).
3. После завершения миграции этапа T2.1 удалить старые модели и связанные представления в отдельной миграции, сохранив `ChecklistLegacyMapping` как архивную таблицу.

## 5. Инструменты и скрипты миграции

- Миграция данных реализуется в `RunPython`, разбитой на батчи по 500 записей для экономии памяти.
- Для расчёта `step` и заполнения `options` планируется отдельный модуль `backend/catalog/migration_utils/checklist_flatten.py` с юнит-тестами.
- Для экспорта контрольного отчёта использовать существующую инфраструктуру CSV в `backend/audits/reporting.py`, дополнив её функцией генерации выгрузки на основе `ChecklistItem`.

## 6. Проверки после миграции

1. Django `check` и `migrate` на локальной базе — гарантируют целостность моделей.
2. `pytest` (особенно `backend/tests/test_admin_cabinet_end_to_end.py`) для проверки UI чек-листа с новой схемой.
3. Ручной smoke-тест: создание аудита, заполнение ответов, экспорт чек-листа.
4. Сверка агрегатов (сумма баллов по старой и новой модели) на минимум двух реальных аудитах перед переключением боевого окружения.

## 7. Риски и открытые вопросы

1. **Соответствие зон и категорий.** Требуется подтвердить у методологов, что `ChecklistSection.title` однозначно соответствует зонам (или предоставить таблицу соответствий), иначе `area` может потребовать ручного заполнения перед миграцией.【F:docs/reports/data-inventory-2025-09-24.md†L26-L29】
2. **Вес пунктов.** Значение `weight` временно привязывается к `max_score`; решение о нормализации и пересчёте итогового балла принимается на этапе T2.2 вместе с реализацией `Audit.calculate_score()`.【F:docs/architecture/v3.md†L75-L83】
3. **Исторические отчёты.** Пока старые аудиты не конвертированы, отчёты должны уметь читать обе схемы. Переходный слой и `ChecklistLegacyMapping` необходимо поддерживать минимум до завершения этапа T5.2.
4. **Производительность миграции.** На копии боевой базы требуется измерить время конвертации и оценить необходимость временного отключения UI (ожидается <5 минут при 10–20 тыс. вопросов, но цифры уточнятся после инвентаризации).

## 8. Выходные артефакты этапа

- Настоящий документ (план миграций T1.1).
- Схема моделей (`models.py` + миграции) — будет реализована в T2.1 на основе этого плана.
- Набор SQL/CSV отчётов для валидации (готовятся в рамках T2.1, но параметры и формат описаны выше).
